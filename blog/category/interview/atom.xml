<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: interview | Meta-Interpretation]]></title>
  <link href="http://pfmiles.github.com/blog/category/interview/atom.xml" rel="self"/>
  <link href="http://pfmiles.github.com/"/>
  <updated>2012-02-28T10:20:18+08:00</updated>
  <id>http://pfmiles.github.com/</id>
  <author>
    <name><![CDATA[pf_miles]]></name>
    <email><![CDATA[miles.wy.1@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[面试中的算法]设计包含min函数的栈]]></title>
    <link href="http://pfmiles.github.com/blog/algorithms-in-job-interview-design-a-stack-with-min-function"/>
    <updated>2012-02-28T00:14:00+08:00</updated>
    <id>http://pfmiles.github.com/blog/algorithms-in-job-interview-design-a-stack-with-min-function</id>
    <content type="html"><![CDATA[<p>此问题由<a href="http://blog.csdn.net/v_JULY_v/article/details/6050133">v_JULY_v</a>整理发布并发表于<a href="http://blog.csdn.net/v_JULY_v">blog</a>上, 版权归原作者所有。</p>

<p><strong>问题描述：定义栈的数据结构,要求添加一个 min 函数,能够得到栈的最小元素, 要求函数 min、push 以及 pop 的时间复杂度都是 O(1)</strong></p>

<h3>分析：</h3>

<p>主要是抓住栈的<strong>“还原现场”</strong>的能力 —— 由于随着元素的加入与弹出，“最小元素”随时可能变化；在栈的每一个状态，都要维护一个当前最小元素的记录;随着push或pop，“最小元素”也跟着更新或还原到上一次的状态；所以，“最小元素”应该随着栈元素被记录在栈的每一层。</p>

<!--more-->


<h3>程序：</h3>

<pre><code>class MinStack(object):
    def __init__(self):
    self.arr = []

    def push(self, ele):
    if len(self.arr) == 0:
        # no elements yet
        self.arr.append((ele, ele));# pushes (ele, minEle)
    else:
        self.arr.append((ele, ele if ele &lt; self.arr[-1][1] else self.arr[-1][1]))

    def pop(self):
    return self.arr.pop()[0]

    # using name 'myMin' instead of 'min' because 'min' is a built-in method
    def myMin(self):
    return self.arr[-1][1]

stack = MinStack()
stack.push(5)
print stack.myMin() # 5 expected
stack.push(-1)
stack.push(10)
stack.push(9)

print stack.myMin() # -1 expected
print stack.pop() # 9 expected
</code></pre>

<p>要点：利用栈的“还原上一次记录”的能力, 随时维护当前最小元素</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[面试中的算法]把二元查找树转变成排序的双向链表]]></title>
    <link href="http://pfmiles.github.com/blog/algorithms-in-job-interview-turn-binary-search-tree-to-doubly-linked-list"/>
    <updated>2012-02-27T23:26:00+08:00</updated>
    <id>http://pfmiles.github.com/blog/algorithms-in-job-interview-turn-binary-search-tree-to-doubly-linked-list</id>
    <content type="html"><![CDATA[<p>此问题由<a href="http://blog.csdn.net/v_JULY_v/article/details/6050133">v_JULY_v</a>整理发布并发表于<a href="http://blog.csdn.net/v_JULY_v">blog</a>上, 版权归原作者所有。</p>

<p><strong>问题描述：输入一棵二元查找树,将该二元查找树转换成一个排序的双向链表。要求不能创建任何新的结点,只调整指针的指向</strong></p>

<p>比如二叉搜索树：</p>

<pre><code>       10
      /   \
    4      12
   / \    /  \
  3   5 11    13
</code></pre>

<p>输出应为： 3, 4, 5, 10, 11, 12, 13</p>

<h3>分析：</h3>

<p>处理树状结构很容易想到递归，而二叉搜索树其实恰好是已经排序好的一个结构，而要把它变成数组，只需“中序遍历”即可: 3,4,5,10,11,12,13</p>

<!--more-->


<h3>程序：</h3>

<pre><code># define the data-structure first
class Node(object):
    def __init__(self, left=None, value=None, right=None):
        self.value = value
        self.left = left
        self.right = right

# construct the bin-search tree 
root = Node(None, 10, None)

left = Node(Node(None, 3, None), 4, Node(None, 5, None))

right = Node(Node(None, 11, None), 12, Node(None, 13, None))

root.left = left
root.right = right

def show(node):
    rst = [node.value]
    leftCur, rightCur = node, node
    while leftCur.left != None:
        rst.insert(0, leftCur.left.value)
        leftCur = leftCur.left
    while rightCur.right != None:
        rst.append(rightCur.right.value)
        rightCur = rightCur.right
    print rst

# 3,4,5,10,11,12,13 expected

# the recursive mid-order traverse function
def traverse(node, leftOrRight = None):
    l, r = None, None
    if node.left != None:
        l = traverse(node.left, "left")
        node.left = l
        l.right = node
    if node.right != None:
        r = traverse(node.right, "right")
        node.right = r
        r.left = node
    if leftOrRight == "left" and r != None:
        return r
    elif leftOrRight == "right" and l != None:
        return l
    else:
        return node

n = traverse(root)

show(n)
</code></pre>

<p>结果输出： [3, 4, 5, 10, 11, 12, 13]</p>

<p>要点除了搞清楚二叉搜索树的特性以及中序遍历的规律外，要注意traverse方法中对于该返回'l' 还是 'r' 或者是node的判断</p>
]]></content>
  </entry>
  
</feed>
